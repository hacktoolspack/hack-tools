Для начала строго рекомендуется прочитать этот мануал внимательно и до конца. Если вы будете тыкать всё подряд в абы каком порядке, в лучшем случае это приведёт к падению программы, в худшем будет BSOD и потенциальная возможность потери данных. Не все функции можно вызывать в произвольном порядке, не все указанные функции следует вызывать, часть была выведена в основном для внутреннего пользования, обо всём этом там чётко написано.
О написании скриптов можно посмотреть в мануале по скриптовому языку Lua (включён в поставку в папке Scripts (Lua Manual.html), также www.lua.org) и посмотреть примеры скриптов в папке Scripts (файлы *.txt).
Если что-то не работает или работает не так, как надо, прочитайте мануал ещё раз 5, потом уже сообщайте о багах. :)
А теперь дополнительные функции и переменные, которые можно вызывать и использовать в своих скриптах.

---------------------------------------------------------------
Функции
---------------------------------------------------------------

number AddBreak(number where,number type1,number type2)
where-адрес, куда поставить бряк
type1-может принимать следующие значения:
	1-бряк опкодный (1 байт), отличается от стандартного лишь другим опкодом, что добавляет немного скрытности
	2-бряк стандартный и всем известный 0xCC, куда ж без него
	3-бряк аппаратный в регистр DR0
	4-бряк аппаратный в регистр DR1
	5-бряк аппаратный в регистр DR2
	6-бряк аппаратный в регистр DR3
type2-на что поставить бряк, может принимать следующие значения: 0-на исполнение, 1-на запись в память, 3-на запись и чтение памяти. Данное поле применимо только к отладочным регистрам (значение type1=3-6), в остальных случаях может принимать любое значение.
result-true, если бряк включён; false-если произошла ошибка (слишком много бряков, например (см. DeleteBreak()))
Функция добавляет бряк в список бряков. Следует иметь в виду, что по умолчанию он не включён (см. EnableBreak()).
Аппаратные бряки на чтение и чтение+запись имеют размер 1

number AddMemoryBreak(number start_addr,number size)
start_addr-начальный адрес памяти для установки бряка
size-размер памяти для бряка
result-true, если бряк установлен; false-если произошла ошибка (неверный диапазон, например)
Функция требует хука 14 прерывания (см. Hook()) и устанавливает бряк на память на исполнение на указанный диапазон страниц. Когда бряк срабатывает, он удаляется. Не будет работать с отключенным PAE

number AddModuleToUnhookList(string library)
library-имя библиотеки, экспорт которой не нужно хукать
result-всегда 0
Функция добавляет библиотеку с указанным именем в список библиотек, экспорт которых хукаться не будет, если стоит соответствующая опция (см. import_meth). Если экспорт этой библиотеки уже похукан, хук с него снимается

number AddSection(string name,string body, number size)
name-имя секции
body-тело секции, что будет в неё записано
size-размер секции, должен равняться размеру данных в теле
result-возвращает 0 в случае успеха; -1 в случае ошибки (например, процесс не дампился, см. Dump())
Функция добавляет в конец сдампленного файла секцию с указанным именем указанного размера и записывает в неё указанные данные. Файл сначала должен быть сдамплен (см. Dump())

number Attach()
result-всегда 0
Функция позволяет аттачиться к запущенному процессу, аналогично нажатию кнопки Attach to process в главном окне программы. При этом вся информация о ранее распаковываемом процессе будет утеряна. Функция не особо оттестирована, поэтому лучше ей не злоупотреблять

number AttachFast(number PID,number thread_id)
PID-id процесса для аттача
thread_id-id потока в этом процессе
result-всегда 0
Функция аналогична функции Attach(), только не показывает окна с процессами. Она использует все текущие настройки и меняет только процесс и поток (полезно, когда пакер использует 2 потока как Armadillo). victim_base и jmp_to_oep должны быть подправлены руками

number CheckMemory(number address)
address-адрес для проверки
result-0, если память не выделена, 1-PAGE_NOACCESS, 2-в другом случае, 3-PAGE_GUARD
Функция проверяет память по указанному адресу. Адрес-VA

number ClearImport()
result-всегда 0
Очищает таблицу импорта для распаковываемого файла

number ClearLog()
result-всегда 0
Очищает лог

number ClearModules()
result-всегда 0
Очищает список модулей для распаковываемого файла. Сделана в основном для внутреннего пользования

number ClearRelocs()
result-всегда 0
Очищает таблицу релокаций для распаковываемого файла

number ClearUnhookList()
result-всегда 0
Очищает список библиотек, экспорт которых хукаться не будет, если стоит соответствующая опция (см. import_meth)

number Continue(bool skiphooked)
skiphooked-вернёт ли функция управление при попадании на бряк похуканной таблицы экспорта или продолжит выполнение дальше
result-всегда 0
Отпускает программу на выполнение, аналог Run в Ольке. Следует иметь в виду, что при остановке на бряке, данный бряк автоматически отключается (см. EnableBreak()). Также программа может неожиданно помереть, неплохо бы это проверить прежде, чем что-то ещё с ней делать (см. break_where)

number CutSections()
result-возвращает 0 в случае успеха; -1 в случае ошибки (например, процесс уже помер)
Функция вызывается для отрезания лишних секций. При отрезании секций порой необходимо восстановить ТЛС (см. ProcessTLS()) и ресурсы (см. ProcessResources()). Функцию следует вызывать после того, как файл уже сдамплен (см. Dump())

bool DeleteBreak(number where)
where-адрес бряка
result-true, если бряк удален; false-если произошла ошибка (бряк не найден в списке, например)
Удалить бряк по указанному адресу из списка бряков

number DeleteBreakAll()
result-всегда 0
Удалить все бряки, включая бряки на память

number DeleteLastSection()
result-возвращает 0 в случае успеха; -1 в случае ошибки (например, процесс не дампился, см. Dump())
Функция удаляет последнюю секцию в сдампленом файле. Файл сначала должен быть сдамплен (см. Dump())

number DeleteMemoryBreaks()
result-всегда 0
Функция удаляет все установленные бряки на память

number Detach()
result-всегда 0
Функция позволяет отцепиться от запущенного процесса. Функция не особо оттестирована, поэтому лучше ей не злоупотреблять

bool DisableBreak(number where)
where-адрес бряка
result-true, если бряк выключен; false-если произошла ошибка (бряк не найден в списке, например)
Отключить бряк по указанному адресу

number DisableBreakAll()
result-всегда 0
Отключить все бряки

bool Disasm(number where)
where-адрес, откуда дизассемблировать
result-0, если случилась ошибка (память не может быть прочитана, например); 1, если кнопка OK или Enter были нажаты; 2 в противном случае
Функция дизассемблирует код по указанному адресу и показывает его пользователю

number Dump()
result-возвращает 0, если сдампилось успешно; -1, если произошла ошибка (например, процесс помер уже)
Сделать дамп процесса. Процесс для распаковки дампится в память. Необходимо с ним далее проделать нужные вещи (импорт, релоки, ТЛС, оверлей), а затем уже сохранить (см. SaveFile())

number DumpForRelocs()
result-возвращает 0, если сдампилось успешно; -1, если произошла ошибка (например, процесс помер уже)
Для восстановления релоков (только для DLL) необходимо либо запустить дополнительную загрузку DLL (см. PreLoad()), либо воспользоваться этой функцией. В DLL необходимо дойти до OEP, а затем запустить эту функцию. Далее процесс необходимо убить и запустить заново, уже потом можно будет вызывать RestoreImportRelocs()

number EmulateCPUID(number active)
active-принимает 2 значения: 0-выключить эмуляцию, 1-включить эмуляцию
result-всегда 0
Функция требует хука 13 прерывания (см. Hook()) и ядро на аппаратной виртуализации и общается напрямую с драйвером, лишний раз её лучше не дёргать. По умолчанию выключена

number EmulateRDTSC(number active,number shift)
active-принимает 2 значения: 0-выключить эмуляцию, 1-включить эмуляцию
shift-см. time_delta
result-всегда 0
Функция требует хука 1 и 13 прерывания (см. Hook()) и общается напрямую с драйвером, лишний раз её лучше не дёргать. По умолчанию выключена

bool EnableBreak(number where)
where-адрес бряка
result-true, если бряк включён; false-если произошла ошибка (бряк не найден в списке, например)
Включить бряк по указанному адресу. Следует иметь в виду, что бряк после добавления надо ещё и включать, ибо по дефолту он не включён. Также следует его включать и после остановки на нём. Ибо, если программа остановилась на бряке, он автоматически выключается

number ExecuteFunction(string library, string function, number arg1, number arg2, number arg3, number arg4, number arg5)
library-имя библиотеки, из которой должна быть выполнена функция
function-имя функции для выполнения
arg1-arg5-список аргументов для функции
result-возвращает значение регистра eax после выполнения функции в случае успеха; -1, если произошла ошибка (например, библиотека не найдена)
Функция выполняет указанную функцию из указанной библиотеки с указанными параметрами в контексте распаковываемой программы. При вызове этой функции библиотека автоматически подгружается в процесс (см. LoadExtraLibrary()). Следует иметь в виду, что аргументов должно быть передано именно 5! Если функция принимает меньше аргументов, дополнить нулями

number Find(string buf,number length,number start,number end)
buf-строка с данными для поиска
length-размер данных в buf в байтах
start-адрес начала поиска в VA
end-адрес окончания поиска в VA
result-адрес, по которому найдено; 0 в случае ошибки (например, процесс уже помер) или не найдено
Функция ищет указанную последовательность байтов с указанного адреса по указанный адрес, возвращая найденный адрес или 0 в случае ошибки. Порядок байтов в памяти такой же, как и порядок байтов в строке. Функция ищет точную последовательность байтов, поэтому и буфер должен содержать точные байты (пример: "\104\101\108\108\111" обозначает строку "hello"; ее также можно задать и как string.char(0x68,0x65,0x6c,0x6c,0x6f))

number FindByMask(string buf,number length,number start,number end)
buf-строка с данными для поиска
length-размер данных в buf в байтах
start-адрес начала поиска в VA
end-адрес окончания поиска в VA
result-адрес, по которому найдено; 0 в случае ошибки (например, процесс уже помер) или не найдено
Функция ищет указанную последовательность байтов с указанного адреса по указанный адрес, возвращая найденный адрес или 0 в случае ошибки. Порядок байтов в памяти такой же, как и порядок байтов в строке. Функция позволяет использовать маску (пример: "558?EC")

number FindOEP()
result-OEP программы; 0 в случае ошибки
Показывает стандартное и всем известное окошко выбора OEP finder, результат работы которого и возвращает данная функция

number FullUnpack()
result-всегда 0
Основная функция для полной распаковки. Именно она вызывается при нажатии на кнопку Full unpack в главном окне программы. Для её работы необходимо выставить все начальные значения в главном окне программы

number GetModuleAddress(string library)
library-имя библиотеки, адрес которой нужно получить
result-возвращает адрес библиотеки; 0 в случае ошибки (например, библиотека не найдена)
Функция возвращает адрес указанной библиотеки или 0 в случае ошибки

number GetOrdinalAddress(string library,number ordinal)
library-имя библиотеки с функцией, адрес которой нужно получить
ordinal-ординал функции, адрес которой нужно получить
result-возвращает адрес функции из библиотеки; 0 в случае ошибки (например, функция не найдена)
Функция возвращает адрес функции с указанным ординалом из указанной библиотеки или 0 в случае ошибки

number GetProcAddress(string library,string function)
library-имя библиотеки с функцией, адрес которой нужно получить
function-имя функции, адрес которой нужно получить
result-возвращает адрес функции из библиотеки; 0 в случае ошибки (например, функция не найдена)
Функция возвращает адрес указанной функции из указанной библиотеки или 0 в случае ошибки

number Hook(number victim_id, number int1, number int13, number int14)
victim_id-PID распаковываемого процесса
int1,int13,int14-что делать с прерыванием, принимает следующие значения: 0-ничего не делать, 1-захучить прерывание, 2-расхучить прерывание
result-всегда 0
Данная функция посылает команду непосредственно драйверу. Сделана в основном для внутреннего пользования, строго не рекомендуется её трогать, иначе можно получить BSOD. По умолчанию прерывания 1, 13 и 14 похуканы, а victim_id настроен на распаковываемый процесс

string IdentifyAddressLib(number address)
address-адрес внутри библиотеки
result-имя библиотеки; -1, если адрес не найден
Функция возвращает имя библиотеки, которая содержит указанный адрес

string IdentifyFuncLib(number address)
address-адрес функции импорта для распознавания
result-имя библиотеки; -1, если функция не найдена
Функция возвращает имя библиотеки, которая содержит указанную функцию импорта

string IdentifyFuncName(number address)
address-адрес функции импорта для распознавания
result-имя функции; -1, если функция не найдена
Функция возвращает имя функции импорта, адрес который указан

string IdentifyFuncOrdinal(number address)
address-адрес функции импорта для распознавания
result-ординал функции; -1, если функция не найдена
Функция возвращает ординал функции импорта, адрес который указан

number ImportAdd(number RVA)
RVA-адрес инструкции, которая использует импорт (call dword ptr[xxx], jmp dword ptr[xxx], mov eax,dword ptr[xxx] и т. д.)
result-0 при успехе; 1 при ошибке чтения указанной памяти; 2, если не похоже, что инструкция использует импорт; 3, если функция не была распознана
Функция использует только статические методы для распознания функций, в случае перенаправленного импорта она не справится (см. ImportTraceAdd())

number ImportTraceAdd(number RVA)
RVA-адрес инструкции, которая использует импорт (call dword ptr[xxx], jmp dword ptr[xxx], mov eax,dword ptr[xxx] и т. д.)
result-0 при успехе; 1 при ошибке чтения указанной памяти; 2, если не похоже, что инструкция использует импорт; 3, если трассировка обломалась
Функция использует трассировку для распознания функций

number/string InputValue(string caption,string default)
caption-заголовок окна ввода
default-значение по умолчанию, которое будет выведено в строке ввода
result-возвращает строку или число, которая была введена; -1, если была нажата кнопка cancel
Функция показывает окно с указанным заголовком и строкой для ввода и возвращает введённую строку или число или -1

number InputYesNo(string caption,string text)
caption-заголовок окна да/нет
text-текст окна да/нет
result-0, если Нет было нажато; 1, если Да было нажато
Функция показывает окно с заданным заголовком и текстом и кнопками Да и Нет и возвращает результат о нажатой кнопке

number IsEnabled(number where)
where-адрес бряка
result-счётчик включений бряка; 0-если бряк выключен или произошла ошибка (бряк не найден в списке, например)
Функция позволяет проверить, включён ли бряк по указанному адресу. Сделана на всякий случай для людей с плохой памятью :)

number IsExist(number where)
where-адрес бряка
result-счётчик существований бряка; 0-если бряк не существует
Функция позволяет проверить, существует ли бряк по указанному адресу. Сделана на всякий случай для людей с плохой памятью :)

number KillTimer()
result-всегда 0
Функция убивает таймер, поставленный TerminateOnTimer

number LoadExtraLibrary(string library)
library-имя библиотеки, которую нужно загрузить
result-возвращает 0, если успешно загружено; -1, если произошла ошибка (например, библиотека не найдена)
Функция загружает указанную библиотеку в адресное пространство распаковываемой программы

number ModuleHook(number module_base)
module_base-imagebase модуля
result-всегда 0
Функция добавляет модуль с указанным imagebase в список модулей и хукает его экспорт, если стоит соответствующая опция (см. import_meth)

number ModuleUnhook(number module_base)
module_base-imagebase модуля
result-всегда 0
Функция анхукает экспорт указанного модуля. Более его экспорт хукаться не будет

number NextInstr(number where)
where-адрес инструкции
result-возвращает адрес следующей инструкции; 0 в случае ошибки (например, плохой адрес)
Функция для заданного адреса инструкции возвращает адрес следующей за ней инструкции

number Pause(string message)
message-сообщение, которое будет показано в MessageBox
result-всегда 0
Функция приостанавливает выполнение скрипта и показывает сообщение. После нажатия кнопки OK в окне сообщения выполнение скрипта продолжится

number PreLoad()
result-0, если процесс был насильно убит; 1-если функция успешно отработала или же это EXE файл и галка Use force unpacking не стоит
Функция используется для Force unpacking (что это такое, можно прочитать в Readme.rus.txt), также она позволяет восстановить релоки (только для DLL). Перед восстановлением релоков (см. RestoreImportRelocs()) необходимо вызывать либо эту функцию, либо см. DumpForRelocs(). Перед использованием этой функции необходимо выставить в главном окне OEP (также см. jmp_to_oep). Она отличается от DumpForRelocs() тем, что сама проходит до указанного OEP и сама убивает процесс; в DumpForRelocs() до OEP придётся идти руками, процесс придётся убивать также руками (см. Terminate())

number ProcessDelphiInit(bool static)
static-статическая или динамическая трассировка
result-возвращает 0 в случае успеха; -1 в случае ошибки (например, процесс не дампился, см. Dump())
Функция восстанавливает таблицу инициализации для Delphi, если выставлен флаг delphi_init. Следует вызывать перед сохранением файла и после того, как файл уже сдамплен и секции обрезаны

number ProcessExport()
result-возвращает 0 в случае успеха; -1 в случае ошибки (например, процесс уже помер)
Восстановить экспорт в файле. Экспорт сразу пишется в отдельную секцию .edata. Вызывать её необязательно. Только если изначально экспорт не попадает в файл (в основном при отрезании секций (см. CutSections())), необходима перестройка. Функцию следует вызывать после того, как файл уже сдамплен (см. Dump())

number ProcessOverlay()
result-возвращает 0 в случае успеха; -1 в случае ошибки (например, процесс не дампился, см. Dump())
Прицепить оверлей к файлу в зависимости от опции append_overlay. Оверлей берётся из исходного файла и цепляется в конец. Следует вызывать непосредственно перед сохранением файла и после того, как файл уже сдамплен, восстановлен импорт и, при необходимости, релоки и ТЛС

number ProcessRelocs()
result-возвращает 0 в случае успеха; -1 в случае ошибки (например, процесс не дампился, см. Dump() и DumpForRelocs() или PreLoad())
Обрабатывает и сохраняет релоки. Может быть использовано и для EXE файла, при этом просто зануляет указатель в заголовке. Функцию следует вызывать после того, как файл уже сдамплен (см. Dump()) и сдамплен для релоков (см. DumpForRelocs() или PreLoad())

number ProcessResources()
result-возвращает 0 в случае успеха; -1 в случае ошибки (например, процесс уже помер)
Функция вызывается для перестройки ресурсов. При этом перестроенные ресурсы сразу в файл не сохраняются (см. SaveResources()). При перестройке ресурсов ненужные секции полезно отрезать (см. CutSections()). Функцию следует вызывать после того, как файл уже сдамплен (см. Dump())

number ProcessTLS()
result-возвращает 0 в случае успеха; -1 в случае ошибки (например, процесс уже помер)
Восстановить ТЛС в файле. ТЛС сразу пишется в отдельную секцию .tls. Вызывать её необязательно. Только если изначально ТЛС не попадает в файл (в основном при отрезании секций (см. CutSections())), необходима перестройка. Функцию следует вызывать после того, как файл уже сдамплен (см. Dump())

number ReadMem(number where,number size)
where-адрес, откуда читать данные
size-размер данных для чтения в байтах, может принимать следующие значения: 1, 2, 3, 4 (и 5, 6, 7, 8 для x64)
result-возвращает прочитанные байты; 0+запись об ошибке в лог в случае ошибки (например, процесс уже помер)
Функция читает указанные данные по указанному адресу, возвращая прочитанные байты или 0 в случае ошибки. Порядок байтов в результате обратный порядку байтов в памяти

number ReadMemDump(number where,number size)
where-адрес, откуда читать данные, указывается в RVA!
size-размер данных для чтения в байтах, может принимать следующие значения: 1, 2, 4
result-возвращает прочитанные байты; 0 в случае ошибки
Функция идентична функции ReadMem(), но только читает данные из дампа. Функцию следует вызывать после того, как файл уже сдамплен (см. Dump())

string ReadMemLarge(number where,number size)
where-адрес, откуда читать данные
size-размер данных для чтения в байтах
result-возвращает строку с прочитанными байтами
Функция читает указанные данные по указанному адресу, возвращая строку с прочитанными байтами. Порядок байтов в результате такой же, как и порядок байтов в памяти

number RemoveLastSEH(number handler)
handler-адрес обработчика в выделенной памяти, который вернула SetLastSEH()
result-всегда 0
Функция удаляет новый обработчик исключений, установленный в SetLastSEH(), и может быть использована во время ручного восстановления импорта, чтобы избежать падения программы, когда трассируется неверная функция

number RestoreImportRelocs()
result-возвращает 0 в случае успеха; -1 в случае ошибки (например, процесс уже помер)
Функция позволяет восстановить импорт и релоки (только для DLL, для восстановления релоков необходим Use force unpacking (см. PreLoad()) или DumpForRelocs() и ProcessRelocs()) с импользованием выбранного метода (см. import_meth). Они сразу же пишутся в отдельные секции .idata и .relocs. Функцию следует вызывать после того, как файл уже сдамплен (см. Dump())

number Resume()
result-предыдущее значение счётчика спячки для потока; -1 в случае ошибки (например, поток помирает)
Вернуть отлаживаемый поток из спячки и заполнить кое-какие отладочные структуры. В основном используется для внутренних целей

number ResumeAllOther()
result-всегда 0
Вернуть все остальные потоки из спячки и заполнить кое-какие отладочные структуры. В основном используется для внутренних целей, но может использоваться и при ручном восстановлении импорта, чтобы другие потоки не мешали

number SaveFile()
result-возвращает 0 в случае успеха; -1 в случае ошибки (например, процесс не дампился, см. Dump())
Сохранить файл на диск. При этом сдампленный файл сохраняется из памяти на диск. Следует вызывать в последнюю очередь, когда файл уже сдамплен, восстановлен импорт и, при необходимости, релоки, ТЛС и оверлей

number SaveImport()
result-возвращает 0 в случае успеха; -1 в случае ошибки (например, процесс не дампился, см. Dump())
Сохранить импорт в файл. Следует вызывать после того, как файл уже сдамплен

number SaveResources()
result-возвращает 0 в случае успеха; -1 в случае ошибки (например, процесс не дампился, см. Dump())
Сохранить ресурсы в отдельную секцию .rsrc. Следует вызывать уже после того, как ресурсы были выдраны из файла (см. ProcessResources())

number SetLastSEH()
result-адрес обработчика в выделенной памяти
Функция устанавливает новый обработчик исключений, делается это через SetUnhandledExceptionFilter, и может быть использована во время ручного восстановления импорта, чтобы избежать падения программы, когда трассируется неверная функция. Имейте в виду, что под x64 функция спасает редко из-за идиотской раскрутки стека

number SetMainBreaks()
result-всегда 0
Установить основные бряки. Вызывается автоматически в Start() и позволяет следить за подгружаемыми модулями, хучить в них экспорт (если стоит соответствующая опция, см. import_meth) и защищать отладочные регистры от просмотра и изменения (если стоит соответствующая опция, см. protect_dr)

number ShowImport()
result-возвращает 0 в случае успеха; -1 в случае ошибки (например, процесс не дампился, см. Dump())
Показывает окошко с таблицей импорта, где импорт можно править вручную

number Start(bool stopsystem)
stopsystem-должно остановиться на system break или позже, имеет значение только для EXE
result-всегда 0
Функция загружает файл. Позволяет загружать как EXE, так и DLL файлы. При этом процесс только запускается или еще ставится бряк на EP или на TLS Callback, и программа останавливается на этом бряке, в зависимости от параметра. Имейте в виду, что при остановке на system break до EP нельзя использовать DR, а некоторые функции могут вернуть ошибку, используйте это на свой страх и риск

number Stop()
result-всегда 0
Функция останавливает процесс распаковки. При этом поток с распаковкой убивается (аналогично нажатию кнопки Убить процесс в главном окне программы)

number Suspend()
result-предыдущее значение счётчика спячки для потока; -1 в случае ошибки (например, поток помирает)
Отправить отлаживаемый поток в спячку. В основном используется для внутренних целей

number SuspendAllOther()
result-всегда 0
Отправить все остальные потоки в спячку. В основном используется для внутренних целей, но может использоваться и при ручном восстановлении импорта, чтобы другие потоки не мешали

number Terminate()
result-всегда 0
Убить процесс распаковываемой программы. При этом стирается вся информация о процессе, какая-либо дальнейшая работа с ним невозможна

number TerminateOnTimer(number timeout)
timeout-таймаут таймера в мс
result-всегда 0
Функция устанавливает таймер, по истечению которого процесс распаковываемой программы будет убит (см. также KillTimer)

number Trace()
result-всегда 0
Сделать один шаг с использованием TF или бряка (см. use_tf). Не стоит этим увлекаться, ибо работает медленно и может быть обнаружено антиотладкой. Программа может неожиданно помереть, неплохо бы это проверить прежде, чем что-то ещё с ней делать (см. break_where)

number TraceAndReplace(number where)
where-адрес для трассировки
result-всегда 0
Функция с использованием Trace() проходит бряк по установленному адресу и восстанавливает бряк. Связано это с автоматическим выключением бряков (см. EnableBreak()) и используется в основном для внутренних целей. Программа может неожиданно помереть, неплохо бы это проверить прежде, чем что-то ещё с ней делать (см. break_where)

number Wait()
result-всегда 0
Функция крутится в цикле обработки бряков и заполняет кое-какие отладочные структуры. В основном используется для внутренних целей

number WriteEx(string line, bool dobreak, bool bald, number textcolor)
line-строчка для выведения в лог
dobreak-нужно ли переносить вывод на новую строку
bald-выводить ли жирным шрифтом
textcolor-цвет текста
result-всегда 0
Служит для продвинутого вывода в лог любой информации. На месте line не обязательно может быть строчка (см. WriteLog())

number WriteLog(string line)
line-строчка для выведения в лог
result-всегда 0
Служит для вывода в лог любой информации. На месте line не обязательно может быть строчка, можно использовать и, например, так: WriteLog(EAX)

number WriteMem(number where,number buf,number size)
where-адрес, куда писать данные
buf-переменная, содержащая данные для записи
size-размер данных для записи в байтах, может принимать следующие значения: 1, 2, 3, 4 (и 5, 6, 7, 8 для x64)
result-возвращает число байт, которые были записаны; 0 в случае ошибки (например, процесс уже помер)
Функция пишет указанные данные по указанному адресу, возвращая число записанных байтов или 0 в случае ошибки. Порядок байтов в памяти обратный порядку байтов в переменной

number WriteMemDump(number where,number buf,number size)
where-адрес, куда писать данные, указывается в RVA!
buf-переменная, содержащая данные для записи
size-размер данных для записи в байтах, может принимать следующие значения: 1, 2, 4
result-возвращает число байт, которые были записаны; 0 в случае ошибки
Функция идентична функции WriteMem(), но только пишет данные в дамп. Функцию следует вызывать после того, как файл уже сдамплен (см. Dump()). Порядок байтов в памяти обратный порядку байтов в переменной

number WriteMemLarge(number where,string buf,number size)
where-адрес, куда писать данные
buf-строка, содержащая данные для записи
size-размер данных для записи в байтах
result-возвращает число байт, которые были записаны; 0 в случае ошибки (например, процесс уже помер)
Функция пишет указанные данные по указанному адресу, возвращая число записанных байтов или 0 в случае ошибки. Порядок байтов в памяти такой же, как и порядок байтов в строке

---------------------------------------------------------------
Переменные
---------------------------------------------------------------

bool autosave_log-включать или нет автосохранение лога, лог пишется в папку Logs, если строк>=5000. По умолчанию принимает значение соответствующего переключателя в главном окне программы

bool append_overlay-включать или нет добавление оверлея. По умолчанию принимает значение соответствующего переключателя в главном окне программы

number break_where-адрес, на котором произошёл текущий останов программы, также может принимать следующие значения для обозначения особых событий:
	0xf00-процесс помер. Бывает, что прога подыхает. Чтоб не гонять скрипт дальше, после выполнения кода (см. Continue(), Trace(), TraceAndReplace()) неплохо бы это проверить
	0xf08-поток помирает и может завершиться в любой момент, используется для внутренних целей
	0xf10-SingleStep. Возникает при использовании TF (trace flag), используется для внутренних целей
	0xf11-Memory Break. Возникает при срабатывании бряка на память
	0xf12-CPUID Break. Возникает при срабатывании бряка на CPUID
	0xf20-произошёл останов на функции при похуканной таблице экспорта модулей, используется для внутренних целей
	0xf30-bUnhandledSingleStep. Произошёл SingleStep, но был вызван не нами, используется для внутренних целей
	0xf31-bUnhandledBreak. Произошёл Break, но был вызван не нами, используется для внутренних целей
	0xf32-bUnhandledBreakMem. Произошёл BreakMem, но был вызван не нами, используется для внутренних целей
	0xf40-bDr0. Произошёл аппаратный бряк по регистру Dr0
	0xf41-bDr1. Произошёл аппаратный бряк по регистру Dr1
	0xf42-bDr2. Произошёл аппаратный бряк по регистру Dr2
	0xf43-bDr3. Произошёл аппаратный бряк по регистру Dr3

number cut_module-отрезать секции с указанного RVA. По умолчанию принимает значение Отрезать модуль по, указанное в главном окне программы

bool cut_sections-включать или нет отрезание последних секций и обработку директорий. По умолчанию принимает значение соответствующего переключателя в главном окне программы

bool delphi_init-включать или нет восстановление таблицы инициализации для Delphi. Следует включать только при уверенности, что программа действительно написана на Delphi. По умолчанию принимает значение соответствующего переключателя в главном окне программы

bool direct_refs-включать или нет функции типа call xxx/jmp xxx/mov reg,imm в таблицу импорта. По умолчанию принимает значение соответствующего переключателя в главном окне программы

bool execute_functions-включать или нет выполнение функций при трассировке импорта. По умолчанию принимает значение соответствующего переключателя в главном окне программы

string file_name-полный путь и имя к распаковываемому файлу

number first_base-полезно для PreLoad() и ДЛЛ-ок, определяет базу для теневой ДЛЛ

number image_size-размер образа, эта переменная после дампа (см. Dump()) возвращает размер образа, до дампа, но после чтения файла с диска возвращает размер образа из файла, иначе 0

number import_meth-метод восстановления импорта, от него зависит, будет ли хукаться экспорт у подгруженных модулей (см. SetMainBreaks()) и сам способ восстановления импорта (см. RestoreImportRelocs()), может принимать следующие значения: 0-соответствует Do not recover, 1-соответствует Smart method, 2-соответствует Smart method+tracer, 3-соответствует Load libraries only. Таблица экспорта подгруженных модулей будет хукаться, если эта переменная равна 2. По умолчанию стоит в положении, соответствующем переключателю в главном окне программы

number import_rva-положить таблицу импорта по этому RVA вместо создания новой секции. По умолчанию принимает значение RVA импорта, указанное в окне импорта программы

bool is_dll-ДЛЛ распаковывается или нет. не следует менять это значение

number jmp_to_oep-OEP для распаковываемой программы, может использоваться для PreLoad(). Это RVA! По умолчанию принимает значение OEP, указанное в главном окне программы

bool leave_direct_refs-оставлять функции импорта call xxx/jmp xxx/mov reg,imm как есть без преобразования в call []/jmp []/mov reg,[]. По умолчанию принимает значение соответствующего переключателя в главном окне программы

bool long_import-хук импорта использует короткий, но более подозрительный трамплин, либо длинный, но более безопасный. Короткий трамплин также влечёт анмаппинг модуля и выделение памяти. По умолчанию принимает значение соответствующего переключателя в главном окне программы

number module_end-считать это число концом модуля при обработке импорта. Это число используется для пропуска указателей, которые ведут внутрь модуля. Это RVA! По умолчанию принимает значение Граница для импорта, указанное в главном окне программы

string parameters-параметры, которые будут переданы распаковываемому приложению. По умолчанию принимает значение Параметры, указанное в главном окне программы

bool path_libs-включать или нет восстановление полного пути к библиотекам импорта. По умолчанию принимает значение соответствующего переключателя в главном окне программы

number platform-равна 32 или 64. не следует менять это значение

bool process_relocs-включать или нет обработку релокаций. По умолчанию принимает значение соответствующего переключателя в главном окне программы

bool protect_dr-включать или нет защиту отладочных регистров. Сама по себе защита будет работать только при вызове соответствующей функции (см. SetMainBreaks()). По умолчанию принимает значение соответствующего переключателя в главном окне программы

bool suspect_functions-включать или нет подозрительные функции в таблицу импорта. По умолчанию принимает значение соответствующего переключателя в главном окне программы

number thread_id-ID текущего потока в распаковываемом процессе. В основном служит для внутренних целей, поэтому трогать его строго не рекомендуется

number time_delta-два вызова инструкции RDTSC или функции GetTickCount один за другим покажут разницу в random(0-255)+delta. При установке в дельте старшего бита, дельта высчитывается самостоятельно и прибавляется младшая часть для сглаживания времени на прерывание. Следует помнить, что хук глобальный в системе. По умолчанию принимает значение Сдвиг для времени, указанное в главном окне программы

bool unhook_inaction-включать или нет динамический анхук экспорта, это увеличивает скорость, но перед обработкой импорта должно быть выключено. По умолчанию выключено

bool use_force-использовать или нет force-метод. По умолчанию принимает значение соответствующего переключателя в главном окне программы

bool use_tf-Trace() использует TF или дизассемблер для вычисления адреса следующей инструкции и установки туда бряка. По умолчанию принимает значение соответствующего переключателя в главном окне программы

number version-равна 40300. не следует менять это значение. нужно только для того, чтобы решить, запускать ли скрипт под какой-либо версией. я не собираюсь обеспечивать полную совместимость с прошлыми версиями, чтобы не превратить QuickUnpack в виндо-подобного монстра :) поэтому скрипт лучше запускать только на той версии, для которой он предназначен, хотя в основном буду стараться делать совместимыми с прошлыми версиями

number victim_base-imagebase, по которому загружен файл для распаковки. В основном служит для внутренних целей, поэтому трогать его строго не рекомендуется

number victim_handle-хендл процесса для распаковки. В основном служит для внутренних целей, поэтому трогать его строго не рекомендуется

number victim_id-PID процесса для распаковки. В основном служит для внутренних целей, поэтому трогать его строго не рекомендуется

Состояние распаковываемого процесса описывается следующими переменными (для x64 имена остались такими же, только увеличилась разрядность):
number EAX-регистр eax/rax
number EBX-регистр ebx/rbx
number ECX-регистр ecx/rcx
number EDX-регистр edx/rdx
number EIP-регистр eip/rip
number EBP-регистр ebp/rbp
number ESP-регистр esp/rsp
number ESI-регистр esi/rsi
number EDI-регистр edi/rdi
number EFLAGS-регистр eflags/rflags. не следует менять это значение
number DR0-регистр dr0. не следует менять это значение
number DR1-регистр dr1. не следует менять это значение
number DR2-регистр dr2. не следует менять это значение
number DR3-регистр dr3. не следует менять это значение
number DR6-регистр dr6. не следует менять это значение
number DR7-регистр dr7. не следует менять это значение
number CS-регистр cs. не следует менять это значение

Следующие регистры только для x64:
number R8-регистр R8
number R9-регистр R9
number R10-регистр R10
number R11-регистр R11
number R12-регистр R12
number R13-регистр R13
number R14-регистр R14
number R15-регистр R15